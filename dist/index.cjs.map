{"version":3,"sources":["../src/types/common/api-response.ts","../src/types/common/pagination.ts","../src/types/auth/nonce.ts","../src/types/auth/api-key.ts","../src/types/auth/link-wallet.ts","../src/types/health/health.ts","../src/types/tokens/erc20.ts","../src/types/pools/uniswapv3.ts","../src/types/pools/uniswapv3-discovery.ts","../src/types/positions/common/list.ts","../src/types/positions/common/ledger.ts","../src/types/positions/common/apr.ts","../src/types/positions/uniswapv3/create.ts","../src/types/positions/uniswapv3/get.ts","../src/types/positions/uniswapv3/update.ts","../src/types/positions/uniswapv3/delete.ts","../src/types/positions/uniswapv3/import.ts"],"names":["ApiErrorCode","z","HealthStatus","ethereumAddressRegex","txHashRegex","bigIntStringRegex"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Common API Response Types\n *\n * Standard response format for all API endpoints.\n * This file will be part of @midcurve/api-types in the future.\n */\n\nimport { z } from 'zod';\n\n/**\n * Standard success response wrapper\n */\nexport interface ApiResponse<T> {\n  success: true;\n  data: T;\n  meta?: {\n    requestId?: string;\n    timestamp?: string;\n    [key: string]: unknown;\n  };\n}\n\n/**\n * Standard error response\n */\nexport interface ApiError {\n  success: false;\n  error: {\n    code: string;\n    message: string;\n    details?: unknown;\n  };\n  meta?: {\n    requestId?: string;\n    timestamp?: string;\n  };\n}\n\n/**\n * Union type for any API response\n */\nexport type ApiResult<T> = ApiResponse<T> | ApiError;\n\n/**\n * Error codes enum for consistent error handling\n */\nexport enum ApiErrorCode {\n  // Client errors (4xx)\n  BAD_REQUEST = 'BAD_REQUEST',\n  UNAUTHORIZED = 'UNAUTHORIZED',\n  FORBIDDEN = 'FORBIDDEN',\n  NOT_FOUND = 'NOT_FOUND',\n  CONFLICT = 'CONFLICT',\n  UNPROCESSABLE_ENTITY = 'UNPROCESSABLE_ENTITY',\n  TOO_MANY_REQUESTS = 'TOO_MANY_REQUESTS',\n\n  // Server errors (5xx)\n  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',\n  BAD_GATEWAY = 'BAD_GATEWAY',\n  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',\n  EXTERNAL_SERVICE_ERROR = 'EXTERNAL_SERVICE_ERROR',\n\n  // Validation errors\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n\n  // Business logic errors\n  TOKEN_NOT_FOUND = 'TOKEN_NOT_FOUND',\n  POOL_NOT_FOUND = 'POOL_NOT_FOUND',\n  POSITION_NOT_FOUND = 'POSITION_NOT_FOUND',\n  CHAIN_NOT_SUPPORTED = 'CHAIN_NOT_SUPPORTED',\n  INVALID_ADDRESS = 'INVALID_ADDRESS',\n\n  // Authentication errors\n  WALLET_ALREADY_REGISTERED = 'WALLET_ALREADY_REGISTERED',\n  INVALID_SIGNATURE = 'INVALID_SIGNATURE',\n  NONCE_INVALID = 'NONCE_INVALID',\n  NONCE_EXPIRED = 'NONCE_EXPIRED',\n  API_KEY_NOT_FOUND = 'API_KEY_NOT_FOUND',\n  WALLET_NOT_FOUND = 'WALLET_NOT_FOUND',\n  INVALID_SIWE_MESSAGE = 'INVALID_SIWE_MESSAGE',\n}\n\n/**\n * Zod schema for API error\n */\nexport const ApiErrorSchema = z.object({\n  success: z.literal(false),\n  error: z.object({\n    code: z.nativeEnum(ApiErrorCode),\n    message: z.string(),\n    details: z.unknown().optional(),\n  }),\n  meta: z\n    .object({\n      requestId: z.string().optional(),\n      timestamp: z.string().optional(),\n    })\n    .catchall(z.unknown())\n    .optional(),\n});\n\n/**\n * Helper to create a success response\n */\nexport function createSuccessResponse<T>(\n  data: T,\n  meta?: ApiResponse<T>['meta']\n): ApiResponse<T> {\n  return {\n    success: true,\n    data,\n    meta: {\n      timestamp: new Date().toISOString(),\n      ...meta,\n    },\n  };\n}\n\n/**\n * Helper to create an error response\n */\nexport function createErrorResponse(\n  code: ApiErrorCode,\n  message: string,\n  details?: unknown,\n  meta?: ApiError['meta']\n): ApiError {\n  return {\n    success: false,\n    error: {\n      code,\n      message,\n      details,\n    },\n    meta: {\n      timestamp: new Date().toISOString(),\n      ...meta,\n    },\n  };\n}\n\n/**\n * HTTP status code mapping for error codes\n */\nexport const ErrorCodeToHttpStatus: Record<ApiErrorCode, number> = {\n  [ApiErrorCode.BAD_REQUEST]: 400,\n  [ApiErrorCode.UNAUTHORIZED]: 401,\n  [ApiErrorCode.FORBIDDEN]: 403,\n  [ApiErrorCode.NOT_FOUND]: 404,\n  [ApiErrorCode.CONFLICT]: 409,\n  [ApiErrorCode.UNPROCESSABLE_ENTITY]: 422,\n  [ApiErrorCode.TOO_MANY_REQUESTS]: 429,\n  [ApiErrorCode.INTERNAL_SERVER_ERROR]: 500,\n  [ApiErrorCode.BAD_GATEWAY]: 502,\n  [ApiErrorCode.SERVICE_UNAVAILABLE]: 503,\n  [ApiErrorCode.EXTERNAL_SERVICE_ERROR]: 502,\n  [ApiErrorCode.VALIDATION_ERROR]: 400,\n  [ApiErrorCode.TOKEN_NOT_FOUND]: 404,\n  [ApiErrorCode.POOL_NOT_FOUND]: 404,\n  [ApiErrorCode.POSITION_NOT_FOUND]: 404,\n  [ApiErrorCode.CHAIN_NOT_SUPPORTED]: 400,\n  [ApiErrorCode.INVALID_ADDRESS]: 400,\n  [ApiErrorCode.WALLET_ALREADY_REGISTERED]: 409,\n  [ApiErrorCode.INVALID_SIGNATURE]: 401,\n  [ApiErrorCode.NONCE_INVALID]: 401,\n  [ApiErrorCode.NONCE_EXPIRED]: 401,\n  [ApiErrorCode.API_KEY_NOT_FOUND]: 404,\n  [ApiErrorCode.WALLET_NOT_FOUND]: 404,\n  [ApiErrorCode.INVALID_SIWE_MESSAGE]: 400,\n};\n","/**\n * Pagination Types\n *\n * Standard pagination types for list endpoints.\n * This file will be part of @midcurve/api-types in the future.\n */\n\nimport { z } from 'zod';\n\n/**\n * Pagination metadata\n */\nexport interface PaginationMeta {\n  total: number;\n  limit: number;\n  offset: number;\n  hasMore: boolean;\n}\n\n/**\n * Paginated response wrapper\n */\nexport interface PaginatedResponse<T> {\n  success: true;\n  data: T[];\n  pagination: PaginationMeta;\n  meta?: {\n    requestId?: string;\n    timestamp?: string;\n    [key: string]: unknown;\n  };\n}\n\n/**\n * Pagination parameters for requests\n */\nexport interface PaginationParams {\n  limit?: number;\n  offset?: number;\n}\n\n/**\n * Default pagination values\n */\nexport const DEFAULT_PAGINATION = {\n  LIMIT: 20,\n  MAX_LIMIT: 100,\n  OFFSET: 0,\n} as const;\n\n/**\n * Zod schema for pagination query parameters\n */\nexport const PaginationParamsSchema = z.object({\n  limit: z\n    .string()\n    .optional()\n    .transform((val) => (val ? parseInt(val, 10) : DEFAULT_PAGINATION.LIMIT))\n    .pipe(\n      z\n        .number()\n        .int()\n        .positive()\n        .max(DEFAULT_PAGINATION.MAX_LIMIT)\n        .default(DEFAULT_PAGINATION.LIMIT)\n    ),\n  offset: z\n    .string()\n    .optional()\n    .transform((val) => (val ? parseInt(val, 10) : DEFAULT_PAGINATION.OFFSET))\n    .pipe(\n      z\n        .number()\n        .int()\n        .nonnegative()\n        .default(DEFAULT_PAGINATION.OFFSET)\n    ),\n});\n\n/**\n * Helper to create pagination metadata\n */\nexport function createPaginationMeta(\n  total: number,\n  limit: number,\n  offset: number\n): PaginationMeta {\n  return {\n    total,\n    limit,\n    offset,\n    hasMore: offset + limit < total,\n  };\n}\n\n/**\n * Helper to create a paginated response\n */\nexport function createPaginatedResponse<T>(\n  data: T[],\n  total: number,\n  limit: number,\n  offset: number,\n  meta?: PaginatedResponse<T>['meta']\n): PaginatedResponse<T> {\n  return {\n    success: true,\n    data,\n    pagination: createPaginationMeta(total, limit, offset),\n    meta: {\n      timestamp: new Date().toISOString(),\n      ...meta,\n    },\n  };\n}\n","/**\n * Nonce Types\n *\n * Types for SIWE nonce generation and validation.\n */\n\nimport { z } from 'zod';\nimport type { ApiResponse } from '../common';\n\n/**\n * Nonce data structure\n */\nexport interface NonceData {\n  nonce: string;\n}\n\n/**\n * GET /api/v1/auth/nonce response\n */\nexport type NonceResponse = ApiResponse<NonceData>;\n\n/**\n * Nonce validation schema\n */\nexport const NonceSchema = z.object({\n  nonce: z.string().regex(/^siwe_[A-Za-z0-9_-]{32}$/, 'Invalid nonce format'),\n});\n","/**\n * API Key Types\n *\n * Types for API key management endpoints.\n */\n\nimport { z } from 'zod';\nimport type { ApiResponse } from '../common';\n\n/**\n * Request to create new API key\n */\nexport interface CreateApiKeyRequest {\n  name: string;\n}\n\n/**\n * API key creation result (includes full key - shown ONCE)\n */\nexport interface CreateApiKeyData {\n  id: string;\n  name: string;\n  key: string; // Full key - ONLY returned at creation\n  keyPrefix: string;\n  createdAt: string;\n}\n\n/**\n * POST /api/v1/user/api-keys response\n */\nexport interface CreateApiKeyResponse extends ApiResponse<CreateApiKeyData> {\n  meta?: {\n    warning: string;\n    timestamp?: string;\n    requestId?: string;\n  };\n}\n\n/**\n * API key display data (for listing - NO full key)\n */\nexport interface ApiKeyDisplay {\n  id: string;\n  name: string;\n  keyPrefix: string; // First 8 chars only\n  lastUsed: string | null;\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * GET /api/v1/user/api-keys response\n */\nexport type ListApiKeysResponse = ApiResponse<ApiKeyDisplay[]>;\n\n/**\n * DELETE /api/v1/user/api-keys/[id] response\n */\nexport interface RevokeApiKeyData {\n  message: string;\n}\n\nexport type RevokeApiKeyResponse = ApiResponse<RevokeApiKeyData>;\n\n/**\n * Validation schemas\n */\nexport const CreateApiKeyRequestSchema = z.object({\n  name: z.string().min(1, 'Name is required').max(100, 'Name too long'),\n});\n","/**\n * Link Wallet Types\n *\n * Types for linking additional wallets to user account.\n */\n\nimport { z } from 'zod';\nimport type { ApiResponse } from '../common';\nimport type { AuthWalletAddress } from '@midcurve/shared';\n\n/**\n * Request to link additional wallet\n */\nexport interface LinkWalletRequest {\n  message: string; // SIWE message JSON\n  signature: string; // Hex signature\n}\n\n/**\n * Wallet data returned after linking\n */\nexport interface LinkWalletData {\n  id: string;\n  address: string;\n  chainId: number;\n  isPrimary: boolean;\n  createdAt: string;\n}\n\n/**\n * POST /api/v1/auth/link-wallet response\n */\nexport type LinkWalletResponse = ApiResponse<LinkWalletData>;\n\n/**\n * GET /api/v1/user/wallets response\n */\nexport type ListWalletsResponse = ApiResponse<AuthWalletAddress[]>;\n\n/**\n * PATCH /api/v1/user/wallets/[id]/primary response\n */\nexport type SetPrimaryWalletResponse = ApiResponse<LinkWalletData>;\n\n/**\n * Validation schemas\n */\nexport const LinkWalletRequestSchema = z.object({\n  message: z.string().min(1, 'SIWE message is required'),\n  signature: z.string().regex(/^0x[a-fA-F0-9]{130}$/, 'Invalid signature format'),\n});\n","/**\n * Health Endpoint Types and Schemas\n *\n * TypeScript types and Zod schemas for health check endpoint.\n */\n\nimport { z } from 'zod';\nimport type { ApiResponse } from '../common/index.js';\n\n/**\n * Health status enum\n */\nexport enum HealthStatus {\n  HEALTHY = 'healthy',\n  DEGRADED = 'degraded',\n  UNHEALTHY = 'unhealthy',\n}\n\n/**\n * Health check response schema\n */\nexport const HealthResponseSchema = z.object({\n  status: z.enum(['healthy', 'degraded', 'unhealthy']),\n  timestamp: z.string().datetime(),\n  environment: z.string(),\n  version: z.string().optional(),\n  uptime: z.number().optional(),\n});\n\n/**\n * Health check data (inferred from schema)\n */\nexport type HealthResponseData = z.infer<typeof HealthResponseSchema>;\n\n/**\n * Health check data interface (explicit definition for clarity)\n */\nexport interface HealthCheckData {\n  status: HealthStatus;\n  timestamp: string;\n  environment: string;\n  version?: string;\n  uptime?: number;\n}\n\n/**\n * Health check response type\n */\nexport type HealthResponse = ApiResponse<HealthResponseData>;\n","/**\n * ERC-20 Token Endpoint Types and Schemas\n *\n * Types and Zod schemas for ERC-20 token management endpoints.\n */\n\nimport { z } from 'zod';\nimport type { ApiResponse } from '../common/index.js';\n\n/**\n * POST /api/v1/tokens/erc20 - Request body\n */\nexport interface CreateErc20TokenRequest {\n  /**\n   * Token contract address (any format, normalized by service)\n   */\n  address: string;\n\n  /**\n   * EVM chain ID\n   */\n  chainId: number;\n}\n\n/**\n * POST /api/v1/tokens/erc20 - Request validation\n */\nexport const CreateErc20TokenRequestSchema = z.object({\n  address: z\n    .string()\n    .min(1, 'Address is required')\n    .regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid Ethereum address format'),\n  chainId: z\n    .number()\n    .int('Chain ID must be an integer')\n    .positive('Chain ID must be positive'),\n});\n\n/**\n * Token data structure (for create/discover response - full Token object)\n */\nexport interface CreateErc20TokenData {\n  id: string;\n  tokenType: 'erc20';\n  name: string;\n  symbol: string;\n  decimals: number;\n  logoUrl?: string;\n  coingeckoId?: string;\n  marketCap?: number;\n  config: {\n    address: string;\n    chainId: number;\n  };\n  createdAt: string; // ISO 8601\n  updatedAt: string; // ISO 8601\n}\n\n/**\n * POST /api/v1/tokens/erc20 - Response\n */\nexport type CreateErc20TokenResponse = ApiResponse<CreateErc20TokenData>;\n\n/**\n * Token search candidate from CoinGecko (lightweight, not in database yet)\n *\n * This represents a token found in CoinGecko's catalog that matches\n * the search criteria. To add it to the database, use POST /api/v1/tokens/erc20\n * with the address and chainId from this candidate.\n */\nexport interface TokenSearchCandidate {\n  /** CoinGecko coin ID */\n  coingeckoId: string;\n  /** Token symbol (uppercase) */\n  symbol: string;\n  /** Token name */\n  name: string;\n  /** Contract address on the specified chain */\n  address: string;\n  /** EVM chain ID where this token exists */\n  chainId: number;\n}\n\n/**\n * GET /api/v1/tokens/erc20/search - Query params\n */\nexport interface SearchErc20TokensQuery {\n  /**\n   * REQUIRED - Chain to search within\n   */\n  chainId: number;\n\n  /**\n   * Optional - partial symbol match (case-insensitive)\n   */\n  symbol?: string;\n\n  /**\n   * Optional - partial name match (case-insensitive)\n   */\n  name?: string;\n\n  /**\n   * Optional - contract address to search for (exact match, case-insensitive)\n   */\n  address?: string;\n}\n\n/**\n * GET /api/v1/tokens/erc20/search - Query validation\n *\n * chainId is REQUIRED\n * At least one of symbol, name, or address must be provided\n */\nexport const SearchErc20TokensQuerySchema = z\n  .object({\n    chainId: z.coerce\n      .number()\n      .int('Chain ID must be an integer')\n      .positive('Chain ID must be positive'),\n    symbol: z.string().min(1, 'Symbol must not be empty').optional(),\n    name: z.string().min(1, 'Name must not be empty').optional(),\n    address: z\n      .string()\n      .regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid Ethereum address format')\n      .optional(),\n  })\n  .refine(\n    (data) => data.symbol !== undefined || data.name !== undefined || data.address !== undefined,\n    {\n      message: 'At least one of symbol, name, or address must be provided',\n      path: ['symbol', 'name', 'address'],\n    }\n  );\n\n/**\n * GET /api/v1/tokens/erc20/search - Response data (array of search candidates)\n */\nexport type SearchErc20TokensData = TokenSearchCandidate[];\n\n/**\n * GET /api/v1/tokens/erc20/search - Response\n */\nexport interface SearchErc20TokensResponse extends ApiResponse<SearchErc20TokensData> {\n  meta?: {\n    count: number; // Number of results returned\n    limit: number; // Max results (always 10)\n    timestamp: string;\n  };\n}\n","/**\n * Type definitions for Uniswap V3 Pool Lookup Endpoint\n *\n * GET /api/pools/uniswapv3/:address\n */\n\nimport { z } from 'zod';\nimport type { UniswapV3Pool } from '@midcurve/shared';\n\n/**\n * Path parameters for pool lookup\n */\nexport interface GetUniswapV3PoolParams {\n  /**\n   * Pool contract address (EIP-55 checksummed or lowercase)\n   * @example \"0xC31E54c7a869B9FcBEcc14363CF510d1c41fa443\"\n   */\n  address: string;\n}\n\n/**\n * Query parameters for pool lookup\n */\nexport interface GetUniswapV3PoolQuery {\n  /**\n   * EVM chain ID where the pool is deployed\n   * @example 1 (Ethereum), 42161 (Arbitrum), 8453 (Base)\n   */\n  chainId: number;\n\n  /**\n   * Whether to enrich response with subgraph metrics (TVL, volume, fees)\n   * Defaults to false if not provided\n   * @example true\n   */\n  metrics?: boolean;\n\n  /**\n   * Whether to enrich response with fee data for APR calculations\n   * Defaults to false if not provided\n   * @example true\n   */\n  fees?: boolean;\n}\n\n/**\n * Response data for pool lookup\n *\n * Includes pool with fresh on-chain state and optional subgraph metrics\n */\nexport interface GetUniswapV3PoolData {\n  /**\n   * Pool data with fresh on-chain state\n   * State (price, liquidity, tick) is always current\n   */\n  pool: UniswapV3Pool;\n\n  /**\n   * Optional subgraph metrics (only included if enrichMetrics=true)\n   * Includes 24-hour TVL, volume, and fees data\n   */\n  metrics?: {\n    /**\n     * Total Value Locked in USD\n     * @example \"1234567.89\"\n     */\n    tvlUSD: string;\n\n    /**\n     * 24-hour trading volume in USD\n     * @example \"567890.12\"\n     */\n    volumeUSD: string;\n\n    /**\n     * 24-hour fees collected in USD\n     * @example \"1234.56\"\n     */\n    feesUSD: string;\n  };\n\n  /**\n   * Optional fee data for APR calculations (only included if fees=true)\n   * Includes 24-hour trading volumes, token prices, and pool liquidity\n   */\n  feeData?: {\n    /**\n     * Token0 24-hour volume in token units (BigInt as string)\n     * @example \"12345678901234\"\n     */\n    token0DailyVolume: string;\n\n    /**\n     * Token1 24-hour volume in token units (BigInt as string)\n     * @example \"123456789012345678\"\n     */\n    token1DailyVolume: string;\n\n    /**\n     * Token0 price in token1 terms (BigInt as string, scaled by token1 decimals)\n     * @example \"4016123456\"\n     */\n    token0Price: string;\n\n    /**\n     * Token1 price in token0 terms (BigInt as string, scaled by token0 decimals)\n     * @example \"248901234567890\"\n     */\n    token1Price: string;\n\n    /**\n     * Current pool liquidity (BigInt as string)\n     * @example \"5234567890123456789\"\n     */\n    poolLiquidity: string;\n\n    /**\n     * Timestamp when fee data was calculated\n     * @example \"2025-10-21T14:30:00.000Z\"\n     */\n    calculatedAt: string;\n  };\n}\n\n/**\n * Schema for path parameters\n *\n * Validates pool contract address format (0x followed by 40 hex characters)\n */\nexport const GetUniswapV3PoolParamsSchema = z.object({\n  address: z\n    .string()\n    .min(1, 'Pool address is required')\n    .regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid pool address format'),\n});\n\n/**\n * Schema for query parameters\n *\n * Validates chainId (positive integer), optional metrics flag, and optional fees flag\n */\nexport const GetUniswapV3PoolQuerySchema = z.object({\n  chainId: z.coerce\n    .number({\n      required_error: 'chainId is required',\n      invalid_type_error: 'chainId must be a number',\n    })\n    .int('chainId must be an integer')\n    .positive('chainId must be positive'),\n\n  metrics: z\n    .string()\n    .optional()\n    .default('false')\n    .transform((val) => val === 'true')\n    .pipe(z.boolean()),\n\n  fees: z\n    .string()\n    .optional()\n    .default('false')\n    .transform((val) => val === 'true')\n    .pipe(z.boolean()),\n});\n","/**\n * Uniswap V3 Pool Discovery Endpoint Types\n *\n * Types for Uniswap V3 pool discovery endpoints.\n * Imports domain types from @midcurve/shared for consistency.\n */\n\nimport { z } from 'zod';\nimport type { PoolDiscoveryResult } from '@midcurve/shared';\nimport type { ApiResponse } from '../common/index.js';\n\n/**\n * GET /api/pools/uniswapv3/discover - Query params\n *\n * All parameters are required for pool discovery.\n */\nexport interface DiscoverUniswapV3PoolsQuery {\n  /**\n   * EVM chain ID where pools exist\n   * Example: 1 (Ethereum), 42161 (Arbitrum), 8453 (Base)\n   */\n  chainId: number;\n\n  /**\n   * First token address (any format, normalized by service)\n   * Example: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"\n   */\n  tokenA: string;\n\n  /**\n   * Second token address (any format, normalized by service)\n   * Example: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"\n   */\n  tokenB: string;\n}\n\n/**\n * GET /api/pools/uniswapv3/discover - Response data\n *\n * Array of pool discovery results from @midcurve/shared.\n * Sorted by TVL descending.\n *\n * Note: The actual response contains serialized versions of these types\n * (bigint fields converted to strings for JSON compatibility).\n */\nexport type DiscoverUniswapV3PoolsData = PoolDiscoveryResult<'uniswapv3'>[];\n\n/**\n * GET /api/pools/uniswapv3/discover - Full response\n */\nexport interface DiscoverUniswapV3PoolsResponse\n  extends ApiResponse<DiscoverUniswapV3PoolsData> {\n  /**\n   * Additional metadata about the discovery results\n   */\n  meta?: {\n    /** Number of pools found */\n    count: number;\n    /** Chain ID queried */\n    chainId: number;\n    /** Timestamp of the response */\n    timestamp: string;\n  };\n}\n\n/**\n * GET /api/pools/uniswapv3/discover - Query validation\n *\n * All three parameters are required for pool discovery.\n */\nexport const DiscoverUniswapV3PoolsQuerySchema = z.object({\n  chainId: z.coerce\n    .number()\n    .int('Chain ID must be an integer')\n    .positive('Chain ID must be positive'),\n  tokenA: z\n    .string()\n    .min(1, 'tokenA is required')\n    .regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid Ethereum address format for tokenA'),\n  tokenB: z\n    .string()\n    .min(1, 'tokenB is required')\n    .regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid Ethereum address format for tokenB'),\n});\n","/**\n * Position List Endpoint Types\n *\n * Types for listing user's positions across all protocols with pagination,\n * filtering, and sorting.\n */\n\nimport type { BigIntToString, PaginatedResponse } from '../../common/index.js';\nimport type { AnyPosition } from '@midcurve/shared';\nimport { z } from 'zod';\nimport { PaginationParamsSchema } from '../../common/pagination.js';\n\n/**\n * Position status filter options\n */\nexport type PositionStatus = 'active' | 'closed' | 'all';\n\n/**\n * Sort field options\n */\nexport type PositionSortBy =\n  | 'createdAt'\n  | 'positionOpenedAt'\n  | 'currentValue'\n  | 'unrealizedPnl';\n\n/**\n * Sort direction options\n */\nexport type SortDirection = 'asc' | 'desc';\n\n/**\n * GET /api/v1/positions/list - Query parameters\n */\nexport interface ListPositionsParams {\n  /**\n   * Filter by protocol(s)\n   * Can be a single protocol or multiple protocols\n   * @example ['uniswapv3', 'orca']\n   */\n  protocols?: string[];\n\n  /**\n   * Filter by position status\n   * - 'active': Only active positions (isActive = true)\n   * - 'closed': Only closed positions (isActive = false)\n   * - 'all': All positions (no filter)\n   * @default 'all'\n   */\n  status?: PositionStatus;\n\n  /**\n   * Sort field\n   * @default 'createdAt'\n   */\n  sortBy?: PositionSortBy;\n\n  /**\n   * Sort direction\n   * @default 'desc'\n   */\n  sortDirection?: SortDirection;\n\n  /**\n   * Number of results per page\n   * @minimum 1\n   * @maximum 100\n   * @default 20\n   */\n  limit?: number;\n\n  /**\n   * Pagination offset\n   * @minimum 0\n   * @default 0\n   */\n  offset?: number;\n}\n\n/**\n * Position data for API response\n *\n * Based on AnyPosition from @midcurve/shared with:\n * - bigint fields converted to strings (for JSON serialization)\n * - Date fields converted to ISO 8601 strings\n * - Fully nested pool and token objects\n * - Config and state as unknown (not protocol-specific)\n */\nexport type ListPositionData = BigIntToString<AnyPosition>;\n\n/**\n * GET /api/v1/positions/list - Response\n */\nexport type ListPositionsResponse = PaginatedResponse<ListPositionData> & {\n  meta: {\n    timestamp: string;\n    filters: {\n      protocols?: string[];\n      status: PositionStatus;\n      sortBy: PositionSortBy;\n      sortDirection: SortDirection;\n    };\n  };\n};\n\n// =============================================================================\n// Zod Schemas\n// =============================================================================\n\n/**\n * Position status enum for validation\n */\nexport const PositionStatusSchema = z.enum(['active', 'closed', 'all']);\n\n/**\n * Sort field enum for validation\n */\nexport const PositionSortBySchema = z.enum([\n  'createdAt',\n  'positionOpenedAt',\n  'currentValue',\n  'unrealizedPnl',\n]);\n\n/**\n * Sort direction enum for validation\n */\nexport const SortDirectionSchema = z.enum(['asc', 'desc']);\n\n/**\n * Zod schema for query parameters\n *\n * Validates and transforms query string parameters to typed values.\n */\nexport const ListPositionsQuerySchema = PaginationParamsSchema.extend({\n  protocols: z\n    .string()\n    .optional()\n    .transform((val) => (val ? val.split(',').map((p) => p.trim()) : undefined))\n    .pipe(z.array(z.string()).optional()),\n\n  status: z\n    .string()\n    .optional()\n    .default('all')\n    .transform((val) => val as 'active' | 'closed' | 'all')\n    .pipe(PositionStatusSchema),\n\n  sortBy: z\n    .string()\n    .optional()\n    .default('createdAt')\n    .transform(\n      (val) =>\n        val as 'createdAt' | 'positionOpenedAt' | 'currentValue' | 'unrealizedPnl'\n    )\n    .pipe(PositionSortBySchema),\n\n  sortDirection: z\n    .string()\n    .optional()\n    .default('desc')\n    .transform((val) => val as 'asc' | 'desc')\n    .pipe(SortDirectionSchema),\n});\n\n/**\n * Inferred type from schema\n */\nexport type ListPositionsQuery = z.infer<typeof ListPositionsQuerySchema>;\n","/**\n * Position Ledger Types\n *\n * Types for the GET /api/v1/positions/uniswapv3/:chainId/:nftId/ledger endpoint\n *\n * Returns ordered list of position ledger events (descending by blockNumber->txIndex->logIndex)\n */\n\nimport type { ApiResponse } from '../../common/api-response.js';\nimport type { SerializedValue } from '../../common/serialization.js';\nimport { z } from 'zod';\n\n/**\n * Serialized ledger event data for API response\n *\n * This is the JSON-serializable version of UniswapV3LedgerEvent from @midcurve/shared\n * All bigint fields are converted to strings for JSON compatibility\n */\nexport interface LedgerEventData {\n  id: string;\n  createdAt: string;\n  updatedAt: string;\n  positionId: string;\n  protocol: 'uniswapv3';\n  previousId: string | null;\n  timestamp: string;\n  eventType: 'INCREASE_POSITION' | 'DECREASE_POSITION' | 'COLLECT';\n  inputHash: string;\n\n  // Financial data (bigint → string)\n  poolPrice: string;\n  token0Amount: string;\n  token1Amount: string;\n  tokenValue: string;\n  rewards: Array<{\n    tokenId: string;\n    tokenAmount: string;\n    tokenValue: string;\n  }>;\n\n  // PnL tracking (bigint → string)\n  deltaCostBasis: string;\n  costBasisAfter: string;\n  deltaPnl: string;\n  pnlAfter: string;\n\n  // Protocol-specific (JSON fields with bigints serialized)\n  config: SerializedValue;\n  state: SerializedValue;\n}\n\n/**\n * Path parameters for ledger endpoint\n */\nexport interface LedgerPathParams {\n  chainId: string;\n  nftId: string;\n}\n\n/**\n * Response type for ledger endpoint\n */\nexport interface LedgerEventsResponse extends ApiResponse<LedgerEventData[]> {\n  meta?: {\n    timestamp: string;\n    count: number;\n    requestId?: string;\n  };\n}\n\n// =============================================================================\n// Zod Schemas\n// =============================================================================\n\n/**\n * Path parameter validation schema\n *\n * Validates chainId and nftId from URL path\n */\nexport const LedgerPathParamsSchema = z.object({\n  /**\n   * Chain ID (e.g., 1 for Ethereum, 42161 for Arbitrum)\n   * Must be a valid positive integer\n   */\n  chainId: z\n    .string()\n    .regex(/^\\d+$/, 'Chain ID must be a valid number')\n    .transform((val) => parseInt(val, 10))\n    .pipe(z.number().int().positive()),\n\n  /**\n   * NFT Position Manager token ID\n   * Can be very large, so we keep as string for validation\n   * Service layer will convert to bigint\n   */\n  nftId: z\n    .string()\n    .regex(/^\\d+$/, 'NFT ID must be a valid number')\n    .min(1, 'NFT ID is required'),\n});\n","/**\n * Position APR Period Types\n *\n * Types for the GET /api/v1/positions/uniswapv3/:chainId/:nftId/apr endpoint\n *\n * Returns ordered list of APR periods for a position (descending by startTimestamp)\n */\n\nimport type { ApiResponse } from '../../common/api-response.js';\nimport { z } from 'zod';\n\n/**\n * Serialized APR period data for API response\n *\n * This is the JSON-serializable version of PositionAprPeriod from @midcurve/shared\n * All bigint fields are converted to strings for JSON compatibility\n */\nexport interface AprPeriodData {\n  // Database fields\n  id: string;\n  createdAt: string;\n  updatedAt: string;\n\n  // Position reference\n  positionId: string;\n\n  // Period boundaries (linked to ledger events)\n  startEventId: string;\n  endEventId: string;\n\n  // Time range\n  startTimestamp: string;\n  endTimestamp: string;\n  durationSeconds: number;\n\n  // Financial metrics (bigint → string)\n  costBasis: string;\n  collectedFeeValue: string;\n\n  // APR metric\n  aprBps: number;\n\n  // Debugging/auditing\n  eventCount: number;\n}\n\n/**\n * Path parameters for APR endpoint\n */\nexport interface AprPathParams {\n  chainId: string;\n  nftId: string;\n}\n\n/**\n * Response type for APR endpoint\n */\nexport interface AprPeriodsResponse extends ApiResponse<AprPeriodData[]> {\n  meta?: {\n    timestamp: string;\n    count: number;\n    requestId?: string;\n  };\n}\n\n// =============================================================================\n// Zod Schemas\n// =============================================================================\n\n/**\n * Path parameter validation schema\n *\n * Validates chainId and nftId from URL path\n * Same validation as ledger endpoint\n */\nexport const AprPathParamsSchema = z.object({\n  /**\n   * Chain ID (e.g., 1 for Ethereum, 42161 for Arbitrum)\n   * Must be a valid positive integer\n   */\n  chainId: z\n    .string()\n    .regex(/^\\d+$/, 'Chain ID must be a valid number')\n    .transform((val) => parseInt(val, 10))\n    .pipe(z.number().int().positive()),\n\n  /**\n   * NFT Position Manager token ID\n   * Can be very large, so we keep as string for validation\n   * Service layer will convert to bigint\n   */\n  nftId: z\n    .string()\n    .regex(/^\\d+$/, 'NFT ID must be a valid number')\n    .min(1, 'NFT ID is required'),\n});\n","/**\n * Position Create Endpoint Types\n *\n * PUT /api/v1/positions/uniswapv3/{chainId}/{nftId}\n *\n * Allows users to manually create a position from their transaction receipt\n * after sending an INCREASE_LIQUIDITY transaction on-chain.\n *\n * Uses shared types from @midcurve/shared with bigint → string conversion for JSON.\n */\n\nimport type { ApiResponse, BigIntToString } from '../../common/index.js';\nimport type { UniswapV3Position } from '@midcurve/shared';\nimport { z } from 'zod';\n\n/**\n * PUT /api/v1/positions/uniswapv3/{chainId}/{nftId} - Request body\n *\n * The user provides data from their transaction receipt after creating a position on-chain.\n * This endpoint creates the position in the database and calculates PnL from the ledger event.\n */\nexport interface CreateUniswapV3PositionRequest {\n  /**\n   * Pool address on the blockchain\n   * EIP-55 checksummed address\n   *\n   * @example \"0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640\" (USDC/WETH on Ethereum)\n   */\n  poolAddress: string;\n\n  /**\n   * Upper tick bound of the position's price range\n   * @example 201120\n   */\n  tickUpper: number;\n\n  /**\n   * Lower tick bound of the position's price range\n   * @example 199120\n   */\n  tickLower: number;\n\n  /**\n   * Owner address (wallet that owns the NFT)\n   * EIP-55 checksummed address\n   * This is the address that sent the INCREASE_LIQUIDITY transaction (msg.sender)\n   *\n   * @example \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0\"\n   */\n  ownerAddress: string;\n\n  /**\n   * OPTIONAL: Address of the quote token (the token used as unit of account)\n   *\n   * If provided:\n   * - Will be validated and normalized to EIP-55 checksum format\n   * - Must match either token0 or token1 in the pool\n   * - Service will use this address to determine isToken0Quote\n   *\n   * If omitted:\n   * - Quote token will be determined automatically using QuoteTokenService\n   * - Respects user preferences → chain defaults → token0 fallback\n   *\n   * @example \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\" (USDC)\n   */\n  quoteTokenAddress?: string;\n\n  /**\n   * INCREASE_LIQUIDITY event data from the transaction receipt\n   *\n   * This event is emitted by the NonfungiblePositionManager contract when\n   * liquidity is added to a position. All data is available in the transaction receipt.\n   */\n  increaseEvent: {\n    /**\n     * Block timestamp when the event occurred\n     * ISO 8601 date string\n     *\n     * @example \"2025-01-15T10:30:00Z\"\n     */\n    timestamp: string;\n\n    /**\n     * Block number where the event occurred\n     * bigint as string\n     *\n     * @example \"12345678\"\n     */\n    blockNumber: string;\n\n    /**\n     * Transaction index within the block\n     * Used for event ordering\n     *\n     * @example 42\n     */\n    transactionIndex: number;\n\n    /**\n     * Log index within the transaction\n     * Used for event ordering\n     *\n     * @example 5\n     */\n    logIndex: number;\n\n    /**\n     * Transaction hash\n     * For reference and verification\n     *\n     * @example \"0x1234567890abcdef...\"\n     */\n    transactionHash: string;\n\n    /**\n     * Amount of liquidity added\n     * bigint as string\n     * This value comes directly from the INCREASE_LIQUIDITY event data\n     *\n     * @example \"1000000000000000000\"\n     */\n    liquidity: string;\n\n    /**\n     * Amount of token0 deposited\n     * bigint as string (in smallest token units)\n     * This value comes directly from the INCREASE_LIQUIDITY event data\n     *\n     * @example \"500000000\" (500 USDC with 6 decimals)\n     */\n    amount0: string;\n\n    /**\n     * Amount of token1 deposited\n     * bigint as string (in smallest token units)\n     * This value comes directly from the INCREASE_LIQUIDITY event data\n     *\n     * @example \"250000000000000000\" (0.25 WETH with 18 decimals)\n     */\n    amount1: string;\n  };\n}\n\n/**\n * Position data for API response\n *\n * Based on UniswapV3Position from @midcurve/shared with:\n * - bigint fields converted to strings (for JSON serialization)\n * - Date fields converted to ISO 8601 strings\n * - Fully nested pool and token objects (no separate ID fields)\n */\nexport type CreateUniswapV3PositionData = BigIntToString<UniswapV3Position>;\n\n/**\n * PUT /api/v1/positions/uniswapv3/{chainId}/{nftId} - Response\n */\nexport type CreateUniswapV3PositionResponse = ApiResponse<CreateUniswapV3PositionData>;\n\n// =============================================================================\n// Zod Schemas\n// =============================================================================\n\n/**\n * Ethereum address validation regex\n * Matches hex addresses with or without 0x prefix\n */\nconst ethereumAddressRegex = /^(0x)?[0-9a-fA-F]{40}$/;\n\n/**\n * Transaction hash validation regex\n * Matches hex hashes with or without 0x prefix\n */\nconst txHashRegex = /^(0x)?[0-9a-fA-F]{64}$/;\n\n/**\n * BigInt string validation regex\n * Matches numeric strings (no scientific notation)\n */\nconst bigIntStringRegex = /^[0-9]+$/;\n\n/**\n * PUT /api/v1/positions/uniswapv3/{chainId}/{nftId} - Request validation\n *\n * Validates the request body for creating a position from user-provided event data.\n *\n * Position state fields are derived from the event data:\n * - liquidity = increaseEvent.liquidity\n * - ownerAddress = user-provided\n * - feeGrowthInside0LastX128 = 0 (new position)\n * - feeGrowthInside1LastX128 = 0 (new position)\n * - tokensOwed0 = 0 (new position)\n * - tokensOwed1 = 0 (new position)\n */\nexport const CreateUniswapV3PositionRequestSchema = z.object({\n  // Position Config\n  poolAddress: z\n    .string()\n    .regex(ethereumAddressRegex, 'Pool address must be a valid Ethereum address'),\n\n  tickUpper: z\n    .number()\n    .int('Tick upper must be an integer'),\n\n  tickLower: z\n    .number()\n    .int('Tick lower must be an integer'),\n\n  // Owner\n  ownerAddress: z\n    .string()\n    .regex(ethereumAddressRegex, 'Owner address must be a valid Ethereum address'),\n\n  // Optional: Quote Token Selection\n  quoteTokenAddress: z\n    .string()\n    .regex(ethereumAddressRegex, 'Quote token address must be a valid Ethereum address')\n    .optional(),\n\n  // INCREASE_LIQUIDITY Event Data\n  increaseEvent: z.object({\n    timestamp: z\n      .string()\n      .datetime({ message: 'Timestamp must be a valid ISO 8601 date string' }),\n\n    blockNumber: z\n      .string()\n      .regex(bigIntStringRegex, 'Block number must be a numeric string'),\n\n    transactionIndex: z\n      .number()\n      .int('Transaction index must be an integer')\n      .nonnegative('Transaction index must be non-negative'),\n\n    logIndex: z\n      .number()\n      .int('Log index must be an integer')\n      .nonnegative('Log index must be non-negative'),\n\n    transactionHash: z\n      .string()\n      .regex(txHashRegex, 'Transaction hash must be a valid hex string'),\n\n    liquidity: z\n      .string()\n      .regex(bigIntStringRegex, 'Liquidity must be a numeric string'),\n\n    amount0: z\n      .string()\n      .regex(bigIntStringRegex, 'Amount0 must be a numeric string'),\n\n    amount1: z\n      .string()\n      .regex(bigIntStringRegex, 'Amount1 must be a numeric string'),\n  }),\n});\n\n/**\n * Path parameters validation\n *\n * Validates chainId and nftId from URL path.\n * Reuses schema from get.schema.ts for consistency.\n */\nexport const CreateUniswapV3PositionParamsSchema = z.object({\n  chainId: z\n    .string()\n    .regex(/^[0-9]+$/, 'Chain ID must be a numeric string')\n    .transform((val) => parseInt(val, 10))\n    .refine((val) => val > 0, { message: 'Chain ID must be positive' }),\n\n  nftId: z\n    .string()\n    .regex(/^[0-9]+$/, 'NFT ID must be a numeric string')\n    .transform((val) => parseInt(val, 10))\n    .refine((val) => val > 0, { message: 'NFT ID must be positive' }),\n});\n","/**\n * GET /api/v1/positions/uniswapv3/:chainId/:nftId\n *\n * Fetches a specific Uniswap V3 position owned by the authenticated user\n * and refreshes its state from on-chain data.\n */\n\nimport type { UniswapV3Position } from '@midcurve/shared';\nimport type { BigIntToString } from '../../common/index.js';\nimport { z } from 'zod';\n\n/**\n * Path parameters for fetching a specific Uniswap V3 position\n */\nexport interface GetUniswapV3PositionParams {\n  /** EVM chain ID (e.g., 1 for Ethereum mainnet) */\n  chainId: string;\n  /** Uniswap V3 NFT token ID */\n  nftId: string;\n}\n\n/**\n * Success response for GET /api/v1/positions/uniswapv3/:chainId/:nftId\n *\n * Returns the complete position data with all bigint fields converted to strings for JSON serialization.\n * The position state is refreshed from on-chain data before being returned.\n */\nexport type GetUniswapV3PositionResponse = BigIntToString<UniswapV3Position>;\n\n// =============================================================================\n// Zod Schemas\n// =============================================================================\n\n/**\n * Zod schema for validating path parameters of GET /api/v1/positions/uniswapv3/:chainId/:nftId\n */\nexport const GetUniswapV3PositionParamsSchema = z.object({\n  /**\n   * EVM chain ID as a string (will be coerced to number)\n   * Must be a valid positive integer\n   */\n  chainId: z.string().transform((val, ctx) => {\n    const parsed = parseInt(val, 10);\n    if (isNaN(parsed) || parsed <= 0) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: 'chainId must be a valid positive integer',\n      });\n      return z.NEVER;\n    }\n    return parsed;\n  }),\n\n  /**\n   * Uniswap V3 NFT token ID\n   * Must be a non-empty string representing a valid token ID\n   */\n  nftId: z.string().min(1, 'nftId must not be empty'),\n});\n\nexport type GetUniswapV3PositionParamsInput = z.input<\n  typeof GetUniswapV3PositionParamsSchema\n>;\nexport type GetUniswapV3PositionParamsOutput = z.output<\n  typeof GetUniswapV3PositionParamsSchema\n>;\n","/**\n * Position Update Endpoint Types\n *\n * PATCH /api/v1/positions/uniswapv3/{chainId}/{nftId}\n *\n * Allows authenticated users to append new events to their position's ledger\n * after executing on-chain transactions (INCREASE_LIQUIDITY, DECREASE_LIQUIDITY, COLLECT).\n *\n * Uses shared types from @midcurve/shared with bigint → string conversion for JSON.\n */\n\nimport type { ApiResponse, BigIntToString } from '../../common/index.js';\nimport type { UniswapV3Position } from '@midcurve/shared';\nimport { z } from 'zod';\n\n/**\n * Event type for Uniswap V3 position events\n *\n * Maps to on-chain NonfungiblePositionManager contract events:\n * - INCREASE_LIQUIDITY: IncreaseLiquidity event\n * - DECREASE_LIQUIDITY: DecreaseLiquidity event\n * - COLLECT: Collect event\n */\nexport type UniswapV3EventType = 'INCREASE_LIQUIDITY' | 'DECREASE_LIQUIDITY' | 'COLLECT';\n\n/**\n * User-provided event data from transaction receipt\n *\n * This represents raw event data from the NonfungiblePositionManager contract.\n * The service layer will calculate all financial fields (poolPrice, costBasis, PnL).\n */\nexport interface UpdateUniswapV3PositionEvent {\n  /**\n   * Event type from the transaction receipt\n   * @example \"INCREASE_LIQUIDITY\"\n   */\n  eventType: UniswapV3EventType;\n\n  /**\n   * Block timestamp when the event occurred\n   * ISO 8601 date string\n   *\n   * @example \"2024-01-20T15:30:00.000Z\"\n   */\n  timestamp: string;\n\n  /**\n   * Block number where the event occurred\n   * bigint as string\n   *\n   * @example \"175500000\"\n   */\n  blockNumber: string;\n\n  /**\n   * Transaction index within the block\n   * Used for event ordering\n   *\n   * @example 50\n   */\n  transactionIndex: number;\n\n  /**\n   * Log index within the transaction\n   * Used for event ordering\n   *\n   * @example 3\n   */\n  logIndex: number;\n\n  /**\n   * Transaction hash\n   * For reference and duplicate detection\n   *\n   * @example \"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890\"\n   */\n  transactionHash: string;\n\n  /**\n   * Liquidity delta (INCREASE_LIQUIDITY, DECREASE_LIQUIDITY only)\n   * bigint as string\n   * REQUIRED for INCREASE_LIQUIDITY and DECREASE_LIQUIDITY\n   * MUST be omitted or \"0\" for COLLECT\n   *\n   * @example \"500000000000000000\"\n   */\n  liquidity?: string;\n\n  /**\n   * Amount of token0 in the event\n   * bigint as string (in smallest token units)\n   *\n   * For INCREASE/DECREASE: amount deposited/withdrawn\n   * For COLLECT: amount collected (fees + principal)\n   *\n   * @example \"250000000\"\n   */\n  amount0: string;\n\n  /**\n   * Amount of token1 in the event\n   * bigint as string (in smallest token units)\n   *\n   * For INCREASE/DECREASE: amount deposited/withdrawn\n   * For COLLECT: amount collected (fees + principal)\n   *\n   * @example \"125000000000000000\"\n   */\n  amount1: string;\n\n  /**\n   * Recipient address (COLLECT only)\n   * EIP-55 checksummed address\n   * REQUIRED for COLLECT events\n   * MUST be omitted for INCREASE_LIQUIDITY and DECREASE_LIQUIDITY\n   *\n   * @example \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0\"\n   */\n  recipient?: string;\n}\n\n/**\n * PATCH /api/v1/positions/uniswapv3/{chainId}/{nftId} - Request body\n *\n * Array of events to append to the position's ledger.\n * Events must be chronologically AFTER existing events (blockNumber → txIndex → logIndex).\n */\nexport interface UpdateUniswapV3PositionRequest {\n  /**\n   * Array of events to add to the position\n   * Events will be sorted and processed in blockchain order\n   * Must all come AFTER existing events in the ledger\n   *\n   * @minItems 1\n   */\n  events: UpdateUniswapV3PositionEvent[];\n}\n\n/**\n * Position data for API response\n *\n * Based on UniswapV3Position from @midcurve/shared with:\n * - bigint fields converted to strings (for JSON serialization)\n * - Date fields converted to ISO 8601 strings\n * - Fully nested pool and token objects\n */\nexport type UpdateUniswapV3PositionData = BigIntToString<UniswapV3Position>;\n\n/**\n * PATCH /api/v1/positions/uniswapv3/{chainId}/{nftId} - Response\n *\n * Returns the fully updated position with refreshed on-chain state\n * and recalculated financial fields.\n */\nexport type UpdateUniswapV3PositionResponse = ApiResponse<UpdateUniswapV3PositionData>;\n\n// =============================================================================\n// Zod Schemas\n// =============================================================================\n\n/**\n * Ethereum address validation regex\n * Matches hex addresses with or without 0x prefix\n */\nconst ethereumAddressRegex = /^(0x)?[0-9a-fA-F]{40}$/;\n\n/**\n * Transaction hash validation regex\n * Matches hex hashes with or without 0x prefix (64 hex chars)\n */\nconst txHashRegex = /^(0x)?[0-9a-fA-F]{64}$/;\n\n/**\n * BigInt string validation regex\n * Matches numeric strings (no scientific notation, no decimals)\n */\nconst bigIntStringRegex = /^[0-9]+$/;\n\n/**\n * Event type validation\n */\nconst eventTypeSchema = z.enum(['INCREASE_LIQUIDITY', 'DECREASE_LIQUIDITY', 'COLLECT'], {\n  errorMap: () => ({\n    message: 'Event type must be INCREASE_LIQUIDITY, DECREASE_LIQUIDITY, or COLLECT',\n  }),\n});\n\n/**\n * Single event validation\n *\n * Validates individual event data with conditional field requirements:\n * - INCREASE_LIQUIDITY: requires liquidity, forbids recipient\n * - DECREASE_LIQUIDITY: requires liquidity, forbids recipient\n * - COLLECT: requires recipient, forbids/ignores liquidity\n */\nconst eventSchema = z\n  .object({\n    eventType: eventTypeSchema,\n\n    timestamp: z\n      .string()\n      .datetime({ message: 'Timestamp must be a valid ISO 8601 date string' }),\n\n    blockNumber: z\n      .string()\n      .regex(bigIntStringRegex, 'Block number must be a numeric string'),\n\n    transactionIndex: z\n      .number()\n      .int('Transaction index must be an integer')\n      .nonnegative('Transaction index must be non-negative'),\n\n    logIndex: z\n      .number()\n      .int('Log index must be an integer')\n      .nonnegative('Log index must be non-negative'),\n\n    transactionHash: z\n      .string()\n      .regex(txHashRegex, 'Transaction hash must be a valid 64-character hex string'),\n\n    liquidity: z\n      .string()\n      .regex(bigIntStringRegex, 'Liquidity must be a numeric string')\n      .optional(),\n\n    amount0: z\n      .string()\n      .regex(bigIntStringRegex, 'Amount0 must be a numeric string'),\n\n    amount1: z\n      .string()\n      .regex(bigIntStringRegex, 'Amount1 must be a numeric string'),\n\n    recipient: z\n      .string()\n      .regex(ethereumAddressRegex, 'Recipient must be a valid Ethereum address')\n      .optional(),\n  })\n  .superRefine((data, ctx) => {\n    // Validate INCREASE_LIQUIDITY and DECREASE_LIQUIDITY events\n    if (data.eventType === 'INCREASE_LIQUIDITY' || data.eventType === 'DECREASE_LIQUIDITY') {\n      // Must have liquidity\n      if (!data.liquidity) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          path: ['liquidity'],\n          message: `Liquidity is required for ${data.eventType} events`,\n        });\n      }\n\n      // Must not have recipient\n      if (data.recipient) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          path: ['recipient'],\n          message: `Recipient is not allowed for ${data.eventType} events (only for COLLECT)`,\n        });\n      }\n    }\n\n    // Validate COLLECT events\n    if (data.eventType === 'COLLECT') {\n      // Must have recipient\n      if (!data.recipient) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          path: ['recipient'],\n          message: 'Recipient is required for COLLECT events',\n        });\n      }\n    }\n  });\n\n/**\n * PATCH /api/v1/positions/uniswapv3/{chainId}/{nftId} - Request validation\n *\n * Validates the request body for updating a position with new events.\n */\nexport const UpdateUniswapV3PositionRequestSchema = z.object({\n  events: z\n    .array(eventSchema)\n    .min(1, 'At least one event is required')\n    .max(100, 'Maximum 100 events allowed per request'),\n});\n\n/**\n * Path parameters validation\n *\n * Validates chainId and nftId from URL path.\n * Reuses same validation logic as GET/PUT/DELETE endpoints.\n */\nexport const UpdateUniswapV3PositionParamsSchema = z.object({\n  chainId: z\n    .string()\n    .regex(/^[0-9]+$/, 'Chain ID must be a numeric string')\n    .transform((val) => parseInt(val, 10))\n    .refine((val) => val > 0, { message: 'Chain ID must be positive' }),\n\n  nftId: z\n    .string()\n    .regex(/^[0-9]+$/, 'NFT ID must be a numeric string')\n    .transform((val) => parseInt(val, 10))\n    .refine((val) => val > 0, { message: 'NFT ID must be positive' }),\n});\n","/**\n * DELETE /api/v1/positions/uniswapv3/:chainId/:nftId\n *\n * Deletes a specific Uniswap V3 position owned by the authenticated user.\n * Idempotent - returns success even if the position doesn't exist.\n */\n\nimport { z } from 'zod';\n\n/**\n * Path parameters for deleting a specific Uniswap V3 position\n */\nexport interface DeleteUniswapV3PositionParams {\n  /** EVM chain ID (e.g., 1 for Ethereum mainnet) */\n  chainId: string;\n  /** Uniswap V3 NFT token ID (positive integer) */\n  nftId: string;\n}\n\n/**\n * Success response for DELETE /api/v1/positions/uniswapv3/:chainId/:nftId\n *\n * Returns an empty data object on successful deletion (or if position didn't exist).\n * The endpoint is idempotent.\n */\nexport interface DeleteUniswapV3PositionResponse {\n  /** Empty object indicating successful deletion */\n  [key: string]: never;\n}\n\n// =============================================================================\n// Zod Schemas\n// =============================================================================\n\n/**\n * Zod schema for validating path parameters of DELETE /api/v1/positions/uniswapv3/:chainId/:nftId\n */\nexport const DeleteUniswapV3PositionParamsSchema = z.object({\n  /**\n   * EVM chain ID as a string (will be coerced to number)\n   * Must be a valid positive integer\n   */\n  chainId: z.string().transform((val, ctx) => {\n    const parsed = parseInt(val, 10);\n    if (isNaN(parsed) || parsed <= 0) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: 'chainId must be a valid positive integer',\n      });\n      return z.NEVER;\n    }\n    return parsed;\n  }),\n\n  /**\n   * Uniswap V3 NFT token ID as a string (will be coerced to number)\n   * Must be a valid positive integer\n   */\n  nftId: z.string().transform((val, ctx) => {\n    const parsed = parseInt(val, 10);\n    if (isNaN(parsed) || parsed <= 0) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: 'nftId must be a valid positive integer',\n      });\n      return z.NEVER;\n    }\n    return parsed;\n  }),\n});\n\nexport type DeleteUniswapV3PositionParamsInput = z.input<\n  typeof DeleteUniswapV3PositionParamsSchema\n>;\nexport type DeleteUniswapV3PositionParamsOutput = z.output<\n  typeof DeleteUniswapV3PositionParamsSchema\n>;\n","/**\n * Position Import Endpoint Types\n *\n * Uses shared types from @midcurve/shared with bigint → string conversion for JSON.\n */\n\nimport type { ApiResponse, BigIntToString } from '../../common/index.js';\nimport type { UniswapV3Position } from '@midcurve/shared';\nimport { z } from 'zod';\n\n/**\n * POST /api/v1/positions/uniswapv3/import - Request body\n */\nexport interface ImportUniswapV3PositionRequest {\n  /**\n   * EVM chain ID where the position exists\n   * @example 1 (Ethereum), 42161 (Arbitrum), 8453 (Base)\n   */\n  chainId: number;\n\n  /**\n   * Uniswap V3 NFT token ID\n   * Each Uniswap V3 position is represented by an NFT in the NonfungiblePositionManager contract\n   * @example 123456\n   */\n  nftId: number;\n}\n\n/**\n * Position data for API response\n *\n * Based on UniswapV3Position from @midcurve/shared with:\n * - bigint fields converted to strings (for JSON serialization)\n * - Date fields converted to ISO 8601 strings\n * - Fully nested pool and token objects (no separate ID fields)\n *\n * Example structure:\n * {\n *   id: \"uuid\",\n *   protocol: \"uniswapv3\",\n *   currentValue: \"1500000000\", // bigint as string\n *   pool: {\n *     id: \"uuid\",\n *     token0: { id: \"uuid\", symbol: \"USDC\", ... },\n *     token1: { id: \"uuid\", symbol: \"WETH\", ... },\n *     ...\n *   },\n *   config: { chainId: 1, nftId: 123456, ... },\n *   state: { liquidity: \"...\", ... },\n *   ...\n * }\n */\nexport type ImportUniswapV3PositionData = BigIntToString<UniswapV3Position>;\n\n/**\n * POST /api/v1/positions/uniswapv3/import - Response\n */\nexport type ImportUniswapV3PositionResponse = ApiResponse<ImportUniswapV3PositionData>;\n\n// =============================================================================\n// Zod Schemas\n// =============================================================================\n\n/**\n * POST /api/v1/positions/uniswapv3/import - Request validation\n *\n * Validates:\n * - chainId: Positive integer (1 for Ethereum, 42161 for Arbitrum, etc.)\n * - nftId: Positive integer (Uniswap V3 NFT token ID)\n *\n * Quote token is NOT included - it's automatically determined by the service\n * using QuoteTokenService (respects user preferences → chain defaults → token0 fallback)\n */\nexport const ImportUniswapV3PositionRequestSchema = z.object({\n  chainId: z\n    .number()\n    .int('Chain ID must be an integer')\n    .positive('Chain ID must be positive'),\n  nftId: z\n    .number()\n    .int('NFT ID must be an integer')\n    .positive('NFT ID must be positive'),\n});\n"]}